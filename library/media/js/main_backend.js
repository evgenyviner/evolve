// Generated by CoffeeScript 1.6.2
/*
 jQuery Waypoints - v2.0.3
 Copyright (c) 2011-2013 Caleb Troughton
 Dual licensed under the MIT license and GPL license.
 https://github.com/imakewebthings/jquery-waypoints/blob/master/licenses.txt
 */
(function () {
    var __indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    },
            __slice = [].slice;

    (function (root, factory) {
        if (typeof define === 'function' && define.amd) {
            return define('waypoints', ['jquery'], function ($) {
                return factory($, root);
            });
        } else {
            return factory(root.jQuery, root);
        }
    })(this, function ($, window) {
        var $w, Context, Waypoint, allWaypoints, contextCounter, contextKey, contexts, isTouch, jQMethods, methods, resizeEvent, scrollEvent, waypointCounter, waypointKey, wp, wps;

        $w = $(window);
        isTouch = __indexOf.call(window, 'ontouchstart') >= 0;
        allWaypoints = {
            horizontal: {},
            vertical: {}
        };
        contextCounter = 1;
        contexts = {};
        contextKey = 'waypoints-context-id';
        resizeEvent = 'resize.waypoints';
        scrollEvent = 'scroll.waypoints';
        waypointCounter = 1;
        waypointKey = 'waypoints-waypoint-ids';
        wp = 'waypoint';
        wps = 'waypoints';
        Context = (function () {
            function Context($element) {
                var _this = this;

                this.$element = $element;
                this.element = $element[0];
                this.didResize = false;
                this.didScroll = false;
                this.id = 'context' + contextCounter++;
                this.oldScroll = {
                    x: $element.scrollLeft(),
                    y: $element.scrollTop()
                };
                this.waypoints = {
                    horizontal: {},
                    vertical: {}
                };
                $element.data(contextKey, this.id);
                contexts[this.id] = this;
                $element.bind(scrollEvent, function () {
                    var scrollHandler;

                    if (!(_this.didScroll || isTouch)) {
                        _this.didScroll = true;
                        scrollHandler = function () {
                            _this.doScroll();
                            return _this.didScroll = false;
                        };
                        return window.setTimeout(scrollHandler, $[wps].settings.scrollThrottle);
                    }
                });
                $element.bind(resizeEvent, function () {
                    var resizeHandler;

                    if (!_this.didResize) {
                        _this.didResize = true;
                        resizeHandler = function () {
                            $[wps]('refresh');
                            return _this.didResize = false;
                        };
                        return window.setTimeout(resizeHandler, $[wps].settings.resizeThrottle);
                    }
                });
            }

            Context.prototype.doScroll = function () {
                var axes,
                        _this = this;

                axes = {
                    horizontal: {
                        newScroll: this.$element.scrollLeft(),
                        oldScroll: this.oldScroll.x,
                        forward: 'right',
                        backward: 'left'
                    },
                    vertical: {
                        newScroll: this.$element.scrollTop(),
                        oldScroll: this.oldScroll.y,
                        forward: 'down',
                        backward: 'up'
                    }
                };
                if (isTouch && (!axes.vertical.oldScroll || !axes.vertical.newScroll)) {
                    $[wps]('refresh');
                }
                $.each(axes, function (aKey, axis) {
                    var direction, isForward, triggered;

                    triggered = [];
                    isForward = axis.newScroll > axis.oldScroll;
                    direction = isForward ? axis.forward : axis.backward;
                    $.each(_this.waypoints[aKey], function (wKey, waypoint) {
                        var _ref, _ref1;

                        if ((axis.oldScroll < (_ref = waypoint.offset) && _ref <= axis.newScroll)) {
                            return triggered.push(waypoint);
                        } else if ((axis.newScroll < (_ref1 = waypoint.offset) && _ref1 <= axis.oldScroll)) {
                            return triggered.push(waypoint);
                        }
                    });
                    triggered.sort(function (a, b) {
                        return a.offset - b.offset;
                    });
                    if (!isForward) {
                        triggered.reverse();
                    }
                    return $.each(triggered, function (i, waypoint) {
                        if (waypoint.options.continuous || i === triggered.length - 1) {
                            return waypoint.trigger([direction]);
                        }
                    });
                });
                return this.oldScroll = {
                    x: axes.horizontal.newScroll,
                    y: axes.vertical.newScroll
                };
            };

            Context.prototype.refresh = function () {
                var axes, cOffset, isWin,
                        _this = this;

                isWin = $.isWindow(this.element);
                cOffset = this.$element.offset();
                this.doScroll();
                axes = {
                    horizontal: {
                        contextOffset: isWin ? 0 : cOffset.left,
                        contextScroll: isWin ? 0 : this.oldScroll.x,
                        contextDimension: this.$element.width(),
                        oldScroll: this.oldScroll.x,
                        forward: 'right',
                        backward: 'left',
                        offsetProp: 'left'
                    },
                    vertical: {
                        contextOffset: isWin ? 0 : cOffset.top,
                        contextScroll: isWin ? 0 : this.oldScroll.y,
                        contextDimension: isWin ? $[wps]('viewportHeight') : this.$element.height(),
                        oldScroll: this.oldScroll.y,
                        forward: 'down',
                        backward: 'up',
                        offsetProp: 'top'
                    }
                };
                return $.each(axes, function (aKey, axis) {
                    return $.each(_this.waypoints[aKey], function (i, waypoint) {
                        var adjustment, elementOffset, oldOffset, _ref, _ref1;

                        adjustment = waypoint.options.offset;
                        oldOffset = waypoint.offset;
                        elementOffset = $.isWindow(waypoint.element) ? 0 : waypoint.$element.offset()[axis.offsetProp];
                        if ($.isFunction(adjustment)) {
                            adjustment = adjustment.apply(waypoint.element);
                        } else if (typeof adjustment === 'string') {
                            adjustment = parseFloat(adjustment);
                            if (waypoint.options.offset.indexOf('%') > -1) {
                                adjustment = Math.ceil(axis.contextDimension * adjustment / 100);
                            }
                        }
                        waypoint.offset = elementOffset - axis.contextOffset + axis.contextScroll - adjustment;
                        if ((waypoint.options.onlyOnScroll && (oldOffset != null)) || !waypoint.enabled) {
                            return;
                        }
                        if (oldOffset !== null && (oldOffset < (_ref = axis.oldScroll) && _ref <= waypoint.offset)) {
                            return waypoint.trigger([axis.backward]);
                        } else if (oldOffset !== null && (oldOffset > (_ref1 = axis.oldScroll) && _ref1 >= waypoint.offset)) {
                            return waypoint.trigger([axis.forward]);
                        } else if (oldOffset === null && axis.oldScroll >= waypoint.offset) {
                            return waypoint.trigger([axis.forward]);
                        }
                    });
                });
            };

            Context.prototype.checkEmpty = function () {
                if ($.isEmptyObject(this.waypoints.horizontal) && $.isEmptyObject(this.waypoints.vertical)) {
                    this.$element.unbind([resizeEvent, scrollEvent].join(' '));
                    return delete contexts[this.id];
                }
            };

            return Context;

        })();
        Waypoint = (function () {
            function Waypoint($element, context, options) {
                var idList, _ref;

                options = $.extend({}, $.fn[wp].defaults, options);
                if (options.offset === 'bottom-in-view') {
                    options.offset = function () {
                        var contextHeight;

                        contextHeight = $[wps]('viewportHeight');
                        if (!$.isWindow(context.element)) {
                            contextHeight = context.$element.height();
                        }
                        return contextHeight - $(this).outerHeight();
                    };
                }
                this.$element = $element;
                this.element = $element[0];
                this.axis = options.horizontal ? 'horizontal' : 'vertical';
                this.callback = options.handler;
                this.context = context;
                this.enabled = options.enabled;
                this.id = 'waypoints' + waypointCounter++;
                this.offset = null;
                this.options = options;
                context.waypoints[this.axis][this.id] = this;
                allWaypoints[this.axis][this.id] = this;
                idList = (_ref = $element.data(waypointKey)) != null ? _ref : [];
                idList.push(this.id);
                $element.data(waypointKey, idList);
            }

            Waypoint.prototype.trigger = function (args) {
                if (!this.enabled) {
                    return;
                }
                if (this.callback != null) {
                    this.callback.apply(this.element, args);
                }
                if (this.options.triggerOnce) {
                    return this.destroy();
                }
            };

            Waypoint.prototype.disable = function () {
                return this.enabled = false;
            };

            Waypoint.prototype.enable = function () {
                this.context.refresh();
                return this.enabled = true;
            };

            Waypoint.prototype.destroy = function () {
                delete allWaypoints[this.axis][this.id];
                delete this.context.waypoints[this.axis][this.id];
                return this.context.checkEmpty();
            };

            Waypoint.getWaypointsByElement = function (element) {
                var all, ids;

                ids = $(element).data(waypointKey);
                if (!ids) {
                    return [];
                }
                all = $.extend({}, allWaypoints.horizontal, allWaypoints.vertical);
                return $.map(ids, function (id) {
                    return all[id];
                });
            };

            return Waypoint;

        })();
        methods = {
            init: function (f, options) {
                var _ref;

                if (options == null) {
                    options = {};
                }
                if ((_ref = options.handler) == null) {
                    options.handler = f;
                }
                this.each(function () {
                    var $this, context, contextElement, _ref1;

                    $this = $(this);
                    contextElement = (_ref1 = options.context) != null ? _ref1 : $.fn[wp].defaults.context;
                    if (!$.isWindow(contextElement)) {
                        contextElement = $this.closest(contextElement);
                    }
                    contextElement = $(contextElement);
                    context = contexts[contextElement.data(contextKey)];
                    if (!context) {
                        context = new Context(contextElement);
                    }
                    return new Waypoint($this, context, options);
                });
                $[wps]('refresh');
                return this;
            },
            disable: function () {
                return methods._invoke(this, 'disable');
            },
            enable: function () {
                return methods._invoke(this, 'enable');
            },
            destroy: function () {
                return methods._invoke(this, 'destroy');
            },
            prev: function (axis, selector) {
                return methods._traverse.call(this, axis, selector, function (stack, index, waypoints) {
                    if (index > 0) {
                        return stack.push(waypoints[index - 1]);
                    }
                });
            },
            next: function (axis, selector) {
                return methods._traverse.call(this, axis, selector, function (stack, index, waypoints) {
                    if (index < waypoints.length - 1) {
                        return stack.push(waypoints[index + 1]);
                    }
                });
            },
            _traverse: function (axis, selector, push) {
                var stack, waypoints;

                if (axis == null) {
                    axis = 'vertical';
                }
                if (selector == null) {
                    selector = window;
                }
                waypoints = jQMethods.aggregate(selector);
                stack = [];
                this.each(function () {
                    var index;

                    index = $.inArray(this, waypoints[axis]);
                    return push(stack, index, waypoints[axis]);
                });
                return this.pushStack(stack);
            },
            _invoke: function ($elements, method) {
                $elements.each(function () {
                    var waypoints;

                    waypoints = Waypoint.getWaypointsByElement(this);
                    return $.each(waypoints, function (i, waypoint) {
                        waypoint[method]();
                        return true;
                    });
                });
                return this;
            }
        };
        $.fn[wp] = function () {
            var args, method;

            method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (methods[method]) {
                return methods[method].apply(this, args);
            } else if ($.isFunction(method)) {
                return methods.init.apply(this, arguments);
            } else if ($.isPlainObject(method)) {
                return methods.init.apply(this, [null, method]);
            } else if (!method) {
                return $.error("jQuery Waypoints needs a callback function or handler option.");
            } else {
                return $.error("The " + method + " method does not exist in jQuery Waypoints.");
            }
        };
        $.fn[wp].defaults = {
            context: window,
            continuous: true,
            enabled: true,
            horizontal: false,
            offset: 0,
            triggerOnce: false
        };
        jQMethods = {
            refresh: function () {
                return $.each(contexts, function (i, context) {
                    return context.refresh();
                });
            },
            viewportHeight: function () {
                var _ref;

                return (_ref = window.innerHeight) != null ? _ref : $w.height();
            },
            aggregate: function (contextSelector) {
                var collection, waypoints, _ref;

                collection = allWaypoints;
                if (contextSelector) {
                    collection = (_ref = contexts[$(contextSelector).data(contextKey)]) != null ? _ref.waypoints : void 0;
                }
                if (!collection) {
                    return [];
                }
                waypoints = {
                    horizontal: [],
                    vertical: []
                };
                $.each(waypoints, function (axis, arr) {
                    $.each(collection[axis], function (key, waypoint) {
                        return arr.push(waypoint);
                    });
                    arr.sort(function (a, b) {
                        return a.offset - b.offset;
                    });
                    waypoints[axis] = $.map(arr, function (waypoint) {
                        return waypoint.element;
                    });
                    return waypoints[axis] = $.unique(waypoints[axis]);
                });
                return waypoints;
            },
            above: function (contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window;
                }
                return jQMethods._filter(contextSelector, 'vertical', function (context, waypoint) {
                    return waypoint.offset <= context.oldScroll.y;
                });
            },
            below: function (contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window;
                }
                return jQMethods._filter(contextSelector, 'vertical', function (context, waypoint) {
                    return waypoint.offset > context.oldScroll.y;
                });
            },
            left: function (contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window;
                }
                return jQMethods._filter(contextSelector, 'horizontal', function (context, waypoint) {
                    return waypoint.offset <= context.oldScroll.x;
                });
            },
            right: function (contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window;
                }
                return jQMethods._filter(contextSelector, 'horizontal', function (context, waypoint) {
                    return waypoint.offset > context.oldScroll.x;
                });
            },
            enable: function () {
                return jQMethods._invoke('enable');
            },
            disable: function () {
                return jQMethods._invoke('disable');
            },
            destroy: function () {
                return jQMethods._invoke('destroy');
            },
            extendFn: function (methodName, f) {
                return methods[methodName] = f;
            },
            _invoke: function (method) {
                var waypoints;

                waypoints = $.extend({}, allWaypoints.vertical, allWaypoints.horizontal);
                return $.each(waypoints, function (key, waypoint) {
                    waypoint[method]();
                    return true;
                });
            },
            _filter: function (selector, axis, test) {
                var context, waypoints;

                context = contexts[$(selector).data(contextKey)];
                if (!context) {
                    return [];
                }
                waypoints = [];
                $.each(context.waypoints[axis], function (i, waypoint) {
                    if (test(context, waypoint)) {
                        return waypoints.push(waypoint);
                    }
                });
                waypoints.sort(function (a, b) {
                    return a.offset - b.offset;
                });
                return $.map(waypoints, function (waypoint) {
                    return waypoint.element;
                });
            }
        };
        $[wps] = function () {
            var args, method;

            method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (jQMethods[method]) {
                return jQMethods[method].apply(null, args);
            } else {
                return jQMethods.aggregate.call(null, method);
            }
        };
        $[wps].settings = {
            resizeThrottle: 100,
            scrollThrottle: 30
        };
        return $w.load(function () {
            return $[wps]('refresh');
        });
    });

}).call(this);

jQuery(window).load(function () {
    if (jQuery().waypoint) {
        jQuery('.t4p-progress-bar').waypoint(function () {
            jQuery(this).css('visibility', 'visible');
            jQuery('.t4p-progress-bar').each(function () {
                var percentage = jQuery(this).find('.t4p-progress-bar-content').data('percentage');
                jQuery(this).find('.t4p-progress-bar-content').css('width', '0%');
                jQuery(this).find('.t4p-progress-bar-content').animate({
                    width: percentage + '%'
                }, 'slow');
            });
        }, {
            triggerOnce: true,
            offset: 'bottom-in-view'
        });
    }

    if (jQuery().waypoint) {
        jQuery('.counters-box').waypoint(function () {
            jQuery(this).find('.display-percentage').each(function () {
                var percentage = jQuery(this).data('percentage');
                jQuery(this).countTo({from: 0, to: percentage, refreshInterval: 10, speed: 1000});
            });
        }, {
            triggerOnce: true,
            offset: 'bottom-in-view'
        });
    }


    jQuery('.simple-products-slider .product-buttons a').text('Add to cart');

    generateCarousel();

    if (jQuery().waypoint) {
        jQuery('.animated').waypoint(function () {

            jQuery(this).css('visibility', 'visible');

            // this code is executed for each appeared element
            var animation_type = jQuery(this).attr('animation_type');
            var animation_duration = jQuery(this).attr('animation_duration');

            jQuery(this).addClass('animated	' + animation_type);

            if (animation_duration) {
                jQuery(this).css('-moz-animation-duration', animation_duration + 's');
                jQuery(this).css('-webkit-animation-duration', animation_duration + 's');
                jQuery(this).css('-ms-animation-duration', animation_duration + 's');
                jQuery(this).css('-o-animation-duration', animation_duration + 's');
                jQuery(this).css('animation-duration', animation_duration + 's');
            }
        }, {triggerOnce: true, offset: 'bottom-in-view'});
    }

    /**
     * For Woocommerce product flexslider
     */

    if (jQuery('body .aside').css('display') == "block") {
        jQuery('body').addClass('has-sidebar');
    }

    if (jQuery().flexslider && jQuery('.woocommerce .images #carousel').length >= 1) {
        var WooThumbWidth = 100;
        if (jQuery('body.woocommerce #sidebar').is(':visible')) {
            wooThumbWidth = 100;
        } else {
            wooThumbWidth = 118;
        }

        if (typeof jQuery('.woocommerce .images #carousel').data('flexslider') !== 'undefined') {
            jQuery('.woocommerce .images #carousel').flexslider('destroy');
            jQuery('.woocommerce .images #slider').flexslider('destroy');
        }

        jQuery('.woocommerce .images #carousel').flexslider({
            animation: 'slide',
            controlNav: false,
            directionNav: false,
            animationLoop: false,
            slideshow: false,
            itemWidth: wooThumbWidth,
            itemMargin: 9,
            touch: false,
            useCSS: false,
            asNavFor: '.woocommerce .images #slider',
            smoothHeight: false
        });

        jQuery('.woocommerce .images #slider').flexslider({
            animation: 'slide',
            controlNav: false,
            animationLoop: false,
            slideshow: false,
            smoothHeight: true,
            touch: true,
            useCSS: false,
            sync: '.woocommerce .images #carousel'
        });
    }

});

// **********************  Woocommerce  ****************************
var generateCarousel = function () {
    if (jQuery().carouFredSel) {
        jQuery('.es-carousel-wrapper').not('.t4p-woo-featured-products-slider').each(function () {
            jQuery(this).find('ul').carouFredSel({
                auto: false,
                prev: jQuery(this).find('.es-nav-prev'),
                next: jQuery(this).find('.es-nav-next'),
                width: '100%',
                height: 'variable',
                align: 'center',
                onCreate: function (data) {
                    jQuery(this).find('.image').css('visibility', 'visible');
                }
            });
        });
        jQuery('.t4p-woo-featured-products-slider').each(function () {
            var carousel = jQuery(this).find('ul');
            carousel.carouFredSel({
                auto: false,
                prev: jQuery(this).find('.es-nav-prev'),
                next: jQuery(this).find('.es-nav-next'),
                align: 'left',
                left: 0,
                width: '100%',
                height: 'variable',
                responsive: true,
                items: {
                    width: 280,
                    height: 'variable',
                    visible: {
                        min: 1,
                        max: 30
                    }
                },
                onCreate: function (data) {
                    jQuery(this).find('.image').css('visibility', 'visible');
                    jQuery(this).parent().css('overflow', '');
                }
            });
        });

        jQuery('.simple-products-slider-variable').each(function () {
            var carousel = jQuery(this).find('ul');
            carousel.carouFredSel({
                auto: false,
                prev: jQuery(this).find('.es-nav-prev'),
                next: jQuery(this).find('.es-nav-next'),
                width: '100%',
                height: 'variable',
                align: 'center'
            });
        });
    }
};

var calcTabsLayout = function (tab_selector) {
    jQuery(tab_selector).each(function () {
        var menuWidth = jQuery(this).parent().width();
        var menuItems = jQuery(this).find('li').length;
        var mod = menuWidth % menuItems;
        var itemWidth = (menuWidth - mod) / menuItems;
        var lastItemWidth = menuWidth - itemWidth * (menuItems - 1);
        jQuery(this).css({'width': menuWidth + 'px'});
        jQuery(this).find('li').css({'width': itemWidth + 'px'});

        jQuery(this).find('li:last').css({'width': lastItemWidth + 'px'}).addClass('no-border-right');
    });
};

var generateCarousel = function () {
    if (jQuery().carouFredSel) {
        jQuery('.clients-carousel').each(function () {
            jQuery(this).find('ul').carouFredSel({
                auto: false,
                prev: jQuery(this).find('.es-nav-prev'),
                next: jQuery(this).find('.es-nav-next'),
                width: '100%',
                height: 'variable',
                align: 'center',
            });
        });

        jQuery('.es-carousel-wrapper').each(function () {
            jQuery(this).find('ul').carouFredSel({
                auto: false,
                prev: jQuery(this).find('.es-nav-prev'),
                next: jQuery(this).find('.es-nav-next'),
                width: '100%',
                height: 'variable',
                align: 'center',
            });
        });
    }
};

/*!
 * jQuery Cycle Lite Plugin
 * http://malsup.com/jquery/cycle/lite/
 * Copyright (c) 2008-2012 M. Alsup
 * Version: 1.7 (20-FEB-2013)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 * Requires: jQuery v1.3.2 or later
 */
;
(function ($) {
    "use strict";

    var ver = 'Lite-1.7';
    var msie = /MSIE/.test(navigator.userAgent);

    $.fn.cycle = function (options) {
        return this.each(function () {
            options = options || {};

            if (this.cycleTimeout)
                clearTimeout(this.cycleTimeout);

            this.cycleTimeout = 0;
            this.cyclePause = 0;

            var $cont = $(this);
            var $slides = options.slideExpr ? $(options.slideExpr, this) : $cont.children();
            var els = $slides.get();
            if (els.length < 2) {
                if (window.console)
                    console.log('terminating; too few slides: ' + els.length);
                return; // don't bother
            }

            // support metadata plugin (v1.0 and v2.0)
            var opts = $.extend({}, $.fn.cycle.defaults, options || {}, $.metadata ? $cont.metadata() : $.meta ? $cont.data() : {});
            var meta = $.isFunction($cont.data) ? $cont.data(opts.metaAttr) : null;
            if (meta)
                opts = $.extend(opts, meta);

            opts.before = opts.before ? [opts.before] : [];
            opts.after = opts.after ? [opts.after] : [];
            opts.after.unshift(function () {
                opts.busy = 0;
            });

            // allow shorthand overrides of width, height and timeout
            var cls = this.className;
            opts.width = parseInt((cls.match(/w:(\d+)/) || [])[1], 10) || opts.width;
            opts.height = parseInt((cls.match(/h:(\d+)/) || [])[1], 10) || opts.height;
            opts.timeout = parseInt((cls.match(/t:(\d+)/) || [])[1], 10) || opts.timeout;

            if ($cont.css('position') == 'static')
                $cont.css('position', 'relative');
            if (opts.width)
                $cont.width(opts.width);
            if (opts.height && opts.height != 'auto')
                $cont.height(opts.height);

            var first = 0;
            $slides.css({position: 'absolute', top: 0}).each(function (i) {
                $(this).css('z-index', els.length - i);
            });

            $(els[first]).css('opacity', 1).show(); // opacity bit needed to handle reinit case
            if (msie)
                els[first].style.removeAttribute('filter');

            if (opts.fit && opts.width)
                $slides.width(opts.width);
            if (opts.fit && opts.height && opts.height != 'auto')
                $slides.height(opts.height);
            if (opts.pause)
                $cont.hover(function () {
                    this.cyclePause = 1;
                }, function () {
                    this.cyclePause = 0;
                });

            var txFn = $.fn.cycle.transitions[opts.fx];
            if (txFn)
                txFn($cont, $slides, opts);

            $slides.each(function () {
                var $el = $(this);
                this.cycleH = (opts.fit && opts.height) ? opts.height : $el.height();
                this.cycleW = (opts.fit && opts.width) ? opts.width : $el.width();
            });

            if (opts.cssFirst)
                $($slides[first]).css(opts.cssFirst);

            if (opts.timeout) {
                // ensure that timeout and speed settings are sane
                if (opts.speed.constructor == String)
                    opts.speed = {slow: 600, fast: 200}[opts.speed] || 400;
                if (!opts.sync)
                    opts.speed = opts.speed / 2;
                while ((opts.timeout - opts.speed) < 250)
                    opts.timeout += opts.speed;
            }
            opts.speedIn = opts.speed;
            opts.speedOut = opts.speed;

            opts.slideCount = els.length;
            opts.currSlide = first;
            opts.nextSlide = 1;

            // fire artificial events
            var e0 = $slides[first];
            if (opts.before.length)
                opts.before[0].apply(e0, [e0, e0, opts, true]);
            if (opts.after.length > 1)
                opts.after[1].apply(e0, [e0, e0, opts, true]);

            if (opts.click && !opts.next)
                opts.next = opts.click;
            if (opts.next)
                $(opts.next).unbind('click.cycle').bind('click.cycle', function () {
                    return advance(els, opts, opts.rev ? -1 : 1);
                });
            if (opts.prev)
                $(opts.prev).unbind('click.cycle').bind('click.cycle', function () {
                    return advance(els, opts, opts.rev ? 1 : -1);
                });

            if (opts.timeout)
                this.cycleTimeout = setTimeout(function () {
                    go(els, opts, 0, !opts.rev);
                }, opts.timeout + (opts.delay || 0));
        });
    };

    function go(els, opts, manual, fwd) {
        if (opts.busy)
            return;
        var p = els[0].parentNode, curr = els[opts.currSlide], next = els[opts.nextSlide];
        if (p.cycleTimeout === 0 && !manual)
            return;

        if (manual || !p.cyclePause) {
            if (opts.before.length)
                $.each(opts.before, function (i, o) {
                    o.apply(next, [curr, next, opts, fwd]);
                });
            var after = function () {
                if (msie)
                    this.style.removeAttribute('filter');
                $.each(opts.after, function (i, o) {
                    o.apply(next, [curr, next, opts, fwd]);
                });
                queueNext(opts);
            };

            if (opts.nextSlide != opts.currSlide) {
                opts.busy = 1;
                $.fn.cycle.custom(curr, next, opts, after);
            }
            var roll = (opts.nextSlide + 1) == els.length;
            opts.nextSlide = roll ? 0 : opts.nextSlide + 1;
            opts.currSlide = roll ? els.length - 1 : opts.nextSlide - 1;
        } else {
            queueNext(opts);
        }

        function queueNext(opts) {
            if (opts.timeout)
                p.cycleTimeout = setTimeout(function () {
                    go(els, opts, 0, !opts.rev);
                }, opts.timeout);
        }
    }

// advance slide forward or back
    function advance(els, opts, val) {
        var p = els[0].parentNode, timeout = p.cycleTimeout;
        if (timeout) {
            clearTimeout(timeout);
            p.cycleTimeout = 0;
        }
        opts.nextSlide = opts.currSlide + val;
        if (opts.nextSlide < 0) {
            opts.nextSlide = els.length - 1;
        } else if (opts.nextSlide >= els.length) {
            opts.nextSlide = 0;
        }
        go(els, opts, 1, val >= 0);
        return false;
    }

    $.fn.cycle.custom = function (curr, next, opts, cb) {
        var $l = $(curr), $n = $(next);
        $n.css(opts.cssBefore);
        var fn = function () {
            $n.animate(opts.animIn, opts.speedIn, opts.easeIn, cb);
        };
        $l.animate(opts.animOut, opts.speedOut, opts.easeOut, function () {
            $l.css(opts.cssAfter);
            if (!opts.sync)
                fn();
        });
        if (opts.sync)
            fn();
    };

    $.fn.cycle.transitions = {
        fade: function ($cont, $slides, opts) {
            $slides.not(':eq(0)').hide();
            opts.cssBefore = {opacity: 0, display: 'block'};
            opts.cssAfter = {display: 'none'};
            opts.animOut = {opacity: 0};
            opts.animIn = {opacity: 1};
        },
        fadeout: function ($cont, $slides, opts) {
            opts.before.push(function (curr, next, opts, fwd) {
                $(curr).css('zIndex', opts.slideCount + (fwd === true ? 1 : 0));
                $(next).css('zIndex', opts.slideCount + (fwd === true ? 0 : 1));
            });
            $slides.not(':eq(0)').hide();
            opts.cssBefore = {opacity: 1, display: 'block', zIndex: 1};
            opts.cssAfter = {display: 'none', zIndex: 0};
            opts.animOut = {opacity: 0};
            opts.animIn = {opacity: 1};
        }
    };

    $.fn.cycle.ver = function () {
        return ver;
    };

// @see: http://malsup.com/jquery/cycle/lite/
    $.fn.cycle.defaults = {
        animIn: {},
        animOut: {},
        fx: 'fade',
        after: null,
        before: null,
        cssBefore: {},
        cssAfter: {},
        delay: 0,
        fit: 0,
        height: 'auto',
        metaAttr: 'cycle',
        next: null,
        pause: false,
        prev: null,
        speed: 1000,
        slideExpr: null,
        sync: true,
        timeout: 4000
    };

})(jQuery);

jQuery(window).load(function () {
    // Counters Box
    jQuery('.t4p-counter-box').not('.t4p-modal .t4p-counter-box').waypoint(function () {
        jQuery(this).find('.display-counter').each(function () {
            jQuery(this).t4p_box_counting();
        });
    }, {
        triggerOnce: true,
        offset: 'bottom-in-view'
    });

    jQuery('.t4p-modal .t4p-counter-box').each(function () {
        jQuery(this).appear(function () {
            jQuery(this).find('.display-counter').each(function () {
                jQuery(this).t4p_box_counting();
            });
        });
    });

    // Testimonials
    function onAfter(curr, next, opts, fwd) {
        var $ht = jQuery(this).height();

        //set the container's height to that of the current slide
        jQuery(this).parent().css('height', $ht);
    }

    if (jQuery().cycle) {
        var reviews_cycle_args = {
            fx: 'fade',
            after: onAfter,
            delay: 0
        };

        if (typeof(js_local_vars) != "undefined" && js_local_vars.testimonials_speed) {
            reviews_cycle_args.timeout = parseInt(js_local_vars.testimonials_speed);
        } else {
            reviews_cycle_args.timeout = parseInt(4000);
        }
        
        jQuery('.reviews').cycle(reviews_cycle_args);
    }

});

//
//
// 
// Responsive Images
//
//
//

var $addmenueffect = jQuery.noConflict();
$addmenueffect("#primary img").addClass("img-responsive");


//
//
// 
// Carousel Slider Arrows
//
//
//

var $jx = jQuery.noConflict();
$jx(document).ready(function () {
    $jx('div#slide_holder').hover(function () {
        $jx(this).find('.arrow span').stop(true, true).fadeIn(200).show(10);
    }, function () {
        $jx(this).find('.arrow span').stop(true, true).fadeOut(200).hide(10);
    });
});

//
//
// 
// Shortcodes
//
//
//   

(function ($) {
    $.fn.equalHeights = function (minHeight, maxHeight) {
        tallest = (minHeight) ? minHeight : 0;
        this.each(function () {
            $(this).css('height', 'auto');
            if ($(this).height() > tallest) {
                tallest = $(this).height();
            }
        });
        if ((maxHeight) && tallest > maxHeight)
            tallest = maxHeight;
        return this.each(function () {
            $(this).height(tallest).css("overflow", "auto");
        });
    }
})(jQuery);


